<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>404 Not Found</title>
  <style>
    body { margin: 0; overflow: hidden; }
  </style>
</head>
<body>
  <!-- Include Three.js and the necessary example scripts -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://threejs.org/examples/js/loaders/FontLoader.js"></script>
  <script src="https://threejs.org/examples/js/geometries/TextGeometry.js"></script>
  <script>
    // Update these variables to change the error messages
    var topMessage = "404";
    var bottomMessage = "NOT FOUND";

    // Rotation settings
    var rotationSpeed = 0.02; // Speed of rotation (radians per frame)
    var offsetDegrees = 270; // Offset between top and bottom text in degrees

    // Variables to store the text meshes
    var topTextMesh, bottomTextMesh;

    // Set up the scene, camera, and renderer
    var scene = new THREE.Scene();
    var camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.z = 50;

    var renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    // Add ambient and point lighting
    var ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
    scene.add(ambientLight);

    var pointLight = new THREE.PointLight(0xffffff, 1);
    pointLight.position.set(50, 50, 50);
    scene.add(pointLight);

    // Load the font and create the 3D text geometries
    var loader = new THREE.FontLoader();
    loader.load('https://threejs.org/examples/fonts/helvetiker_regular.typeface.json', function(font) {
      // Create the top text geometry and mesh
      var topGeometry = new THREE.TextGeometry(topMessage, {
        font: font,
        size: 5,
        height: 1,
        curveSegments: 12,
        bevelEnabled: true,
        bevelThickness: 0.5,
        bevelSize: 0.3,
        bevelOffset: 0,
        bevelSegments: 5
      });
      topGeometry.computeBoundingBox();
      var topCenterOffset = -0.5 * (topGeometry.boundingBox.max.x - topGeometry.boundingBox.min.x);
      var topMaterial = new THREE.MeshPhongMaterial({ color: 0x770000 });
      topTextMesh = new THREE.Mesh(topGeometry, topMaterial);
      topTextMesh.position.x = topCenterOffset;
      topTextMesh.position.y = 4; // Position above center
      // Set initial rotation to 0
      topTextMesh.rotation.x = 0;
      scene.add(topTextMesh);

      // Create the bottom text geometry and mesh
      var bottomGeometry = new THREE.TextGeometry(bottomMessage, {
        font: font,
        size: 2,
        height: 1,
        curveSegments: 12,
        bevelEnabled: true,
        bevelThickness: 0.5,
        bevelSize: 0.3,
        bevelOffset: 0,
        bevelSegments: 5
      });
      bottomGeometry.computeBoundingBox();
      var bottomCenterOffset = -0.5 * (bottomGeometry.boundingBox.max.x - bottomGeometry.boundingBox.min.x);
      var bottomMaterial = new THREE.MeshPhongMaterial({ color: 0x999900 });
      bottomTextMesh = new THREE.Mesh(bottomGeometry, bottomMaterial);
      bottomTextMesh.position.x = bottomCenterOffset;
      bottomTextMesh.position.y = -3; // Position below center
      // Set initial rotation using the offset variable (convert degrees to radians)
      bottomTextMesh.rotation.x = offsetDegrees * (Math.PI / 180);
      scene.add(bottomTextMesh);
    });

    // Animation loop: top text rotates backwards along its X axis, bottom rotates in the opposite way
    function animate() {
      requestAnimationFrame(animate);
      if (topTextMesh) {
        topTextMesh.rotation.x -= rotationSpeed; // Rotate backwards
      }
      if (bottomTextMesh) {
        bottomTextMesh.rotation.x += rotationSpeed; // Rotate forwards (opposite)
      }
      renderer.render(scene, camera);
    }
    animate();

    // Adjust camera and renderer on window resize
    window.addEventListener('resize', function(){
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }, false);
  </script>
</body>
</html>
